#Inkshield Notes
This is my log book for experimenting with the [Inkshield][inkshield] by Nicholas C Lewis.

##Goals and initial thoughts
My goal is to integrate inkshield printing capabilities with Marlin. The rational for integration is both technical and social. There is a very large community using, and contributing to, Marlin. As a firm believer in Linus' Law (many eyes make all bug shallow), this will give us a very good code base and potential for long term contribution.

There were of two potential methods of integration with Marlin. The first is to make a move, and specify a stream of nozzle firings on the ink jet for that move. This is much more complicated to integrate with the move planner and adds overhead. We would need to process a stream of data during the move. It would also be difficult to integrate this with gcode, as the gcode command length is limited in size. This would mean movements and printing stream would be decoupled.
My second proposal is to execute a move and fire the nozzles upon arrival (using a new Mcode). This will decrease 'smoothness' of the printing, and create larger files as each nozzle firing needs an associated position. However, implementation is simpler and the options for expandability should be wider. We should also be able to leverage existing tool change functionality in some way.

Each point generated by the inkshield will require a bit. With 12 nozzles, this requires two bytes. Across a print this is a large amount of data. Streaming from an SD card, will manage the bandwidth better than serial over USB.

##Preprocess (Host)
Drawing from the [DIY inkjet printer][diy_inkjet], we will try and convert a BMP into a series of Gcode moves. We can associate a color range with each inkjet head in the case we have multiples.

##Source code for Inkshield
###Initial impressions
After browsing the [source code][inkshield_github] for the inkshield, I believe there is much potential for contribution.
The inkshield library shows two things.
* There is redundant code
* There are constraints on operation which are not necessary.

[The inkshield operates by writing 4 bits to address a nozzle.][inkshield_theory] The pulse pin then triggers the nozzle firing. The redundant code lies in the selection of the pulse pin. Each pulse pin is implemented as a discrete function, rather than a function taking the pulse pin as the argument. This will allow us to distill the 12 functions into one function, that can use any arbitrary pin. This will aid in our goal of controller agnostic software.

Next, the addressing of the nozzle does not need to be constrained to a single port. In theory we are extending the time required to address the nozzle by a factor of four. Nothing constrains us to addressing a nozzle instantaneously. We can take as long as we would like and still achieve the same result. We are however limited by addressing and firing too fast. There needs to be a 0.5us delay between nozzle firings, so individual pin writes will help our safety margin on top of the 0.7us loop overhead. Along with this, we cannot fire the nozzles more than once every 800us. My experiment will be to distill the current inkshield library into a single function, taking 5 pins as arguments and a 16 bit integer as the 6th. 
The first 4 pins will be for addressing the nozzles. The 5th pin will be the pulse pin. The 16 bit integer will represent which nozzles to fire. We will only use the first 12 bits, with 1 representing a firing of the nozzle and 0 representing a pass.

###Inkshield Class
After expanding these notes, it became obvious that there needs to be some sort of instance of an inkshield. Primarily to keep track of the last nozzle firing. It might be advantageous to use a class with pins declared at instantiation with a member to keep track of the last nozzle firing time. The single method will take the 16 bit integer and return 0 for completion of the firing, or 1 if it is requested to fire too soon.

###Experimental improvements
I am using the "I3Inkshield" Arduino sketch as a basis. I began by modifying the spray_ink method to address multiple pins. "fastio.h" was used from Marlin to provide fast write macros. The addressing was done as follows. 
```C
if(i & 1<<0) 
    WRITE(INK_PINA, 1);
if(i & 1<<1)
    WRITE(INK_PINB, 1);
if(i & 1<<2)
    WRITE(INK_PINC, 1);
if(i & 1<<3)
    WRITE(INK_PIND, 1);
```
"i" is the nozzle number we are addressing. This will write the i value as a 4 bit number represented as logic high pin values. The entire function is shown below, where "INK_*" is a global pin definition.
```C
void spray_ink(uint16_t strip)
{
  //loop through the nozzles
  for(uint8_t i = 0; i <= 11; i++){
    //See if nozzle is set to fire
    if(strip & 1<<i){
      
      //Write the nozzle number to the pin shield as 4 bits
      if(i & 1<<0) 
        WRITE(INK_PINA, 1);
      if(i & 1<<1)
        WRITE(INK_PINB, 1);
      if(i & 1<<2)
        WRITE(INK_PINC, 1);
      if(i & 1<<3)
        WRITE(INK_PIND, 1);
        
      //Fire the Nozzle
      WRITE(INK_PULSE, 1); 
      delayMicroseconds(5);
    
      //Set everything low  
      WRITE(INK_PULSE, 0);
      WRITE(INK_PINA, 0);
      WRITE(INK_PINB, 0);
      WRITE(INK_PINC, 0);
      WRITE(INK_PIND, 0);
    }
  }
  //wait to be sure we don't try to fire nozzles too fast and burn them out
  delayMicroseconds(800);
}
```
In hindsight, this implementation might integrate better with Marlin than a class, as ```#define <PIN_NAME>``` is the most common way of declaring pins. We will however need to remove the ```delayMicroseconds(800)``` as this function should block as little as possible. At this stage of the project we have an understanding of inkshield function, and a very basic and portable example Arduino sketch. The sketch and files can be found in [I3InkShield](./I3InkShield). They are available under the LGPL-2.1.

##Marlin integration notes
In order to integrate inkjet head control into Marlin, we will need a new M code. I have decided to start using the M700+ space as it is vacant and would allow expansion as we add new inkjet related mcodes. However, this may change.
The current implementation uses the same method as the I3InkShield sketch for control, adding a provision for multiple inkjet heads. The changes can be seen [here](https://github.com/sjkelly/Marlin/commit/c0dcb9d726e0e034a6c4905d767b1eea17674e17). Currently we need to send a 'M400' to ensure the move is completed before firing the heads. I am looking into how we can do this in the move buffer for smoother printing.


##References
* [DIY Inkjet Printer - University of Washington][diy_inkjet]
[diy_inkjet]: http://thingiverse-production.s3.amazonaws.com/assets/b4/c4/52/58/94/DIY_Inkjet_Printer.pdf 
* [InkShield][inkshield]
[inkshield]: http://nicholasclewis.com/projects/inkshield/
* [InkShield Theory][inkshield_theory]
[inkshield_theory]: http://nicholasclewis.com/projects/inkshield/theory/
* [InkShield GitHub][inkshield_github]
[inkshield_github]: https://github.com/NicholasCLewis/InkShield "InkShield GitHub"
